package init

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"gopkg.in/AlecAivazis/survey.v1"

	"github.com/morozovcookie/goproject-cli/pkg/cmd/check"
	cmdutil "github.com/morozovcookie/goproject-cli/pkg/cmd/util"
)

type Options struct {
	check.Options

	//	options
	path string

	moduleName string
	projectName string

	projectRootPath string
	projectDirPath string
}

func NewInitOptions() *Options {
	return &Options{}
}

func NewInitCommand() (command *cobra.Command) {
	opts := NewInitOptions()

	command = &cobra.Command{
		Use:   "init [MODULE]",
		Short: "Init project",
		Run: func(cmd *cobra.Command, args []string) {
			cmdutil.CheckErr(opts.Complete(cmd, args))
			cmdutil.CheckErr(opts.Validate())
			cmdutil.CheckErr(opts.Run())
		},
		PreRun: func(cmd *cobra.Command, args []string) {
			cmdutil.CheckErr(opts.Options.Run())
		},
	}

	command.Flags().StringVar(&opts.path, "path", "", "project directory path")

	return command
}

func (v *Options) Complete(cmd *cobra.Command, args []string) (err error) {
	_, _ = fmt.Fprintln(os.Stdout, "reading command parameters. . .")

	if len(args) < 1 {
		return errors.New("not enough arguments")
	}

	v.moduleName = args[0]

	if v.path != "" {
		v.projectDirPath = v.path
		parts := strings.Split(v.path, "/")
		v.projectRootPath = strings.Join(parts[:len(parts)-1], "/")
	}

	return nil
}

func (v *Options) Validate() (err error) {
	_, _ = fmt.Fprintln(os.Stdout, "validating command parameters. . .")

	moduleNameRegExp := regexp.MustCompile(`^((?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9])/(\S+)/(\S+)$`)

	if !moduleNameRegExp.MatchString(v.moduleName) {
		return errors.Errorf(`invalid module name "%s"`, v.moduleName)
	}

	v.projectName = strings.Split(v.moduleName, "/")[2]

	if v.path == "" {
		if v.projectRootPath, err = os.Getwd(); err != nil {
			return err
		}

		v.projectDirPath = filepath.Join(v.projectRootPath, v.projectName)
	}

	return nil
}

func (v *Options) Run() (err error) {
	_, _ = fmt.Fprintln(os.Stdout, `running "init" command. . .`)

	if err = v.changeProjectName(); err != nil {
		return err
	}

	if err = v.changeProjectPath(); err != nil {
		return err
	}

	if err = v.createProjectFolder(); err != nil {
		return err
	}

	return nil
}

func (v *Options) createProjectFolder() (err error) {
	_, _ = fmt.Fprintln(os.Stdout, "creating project folder. . .")

	if err = v.initializeGitRepository(); err != nil {
		return err
	}

	if err = v.createGitIgnoreFile(); err != nil {
		return err
	}

	if err = v.createReadmeFile(); err != nil {
		return err
	}

	return nil
}

func (v *Options) changeProjectName() (err error) {
	isLeaveProjectName := false
	err = survey.AskOne(&survey.Confirm{
		Message: fmt.Sprintf(`project name is "%s" ?`, v.projectName),
	}, &isLeaveProjectName, nil)
	if err != nil {
		return err
	}

	if !isLeaveProjectName {
		parts := strings.Split(v.moduleName, "/")
		err = survey.AskOne(&survey.Input{
			Message: "Type new project name: ",
		}, &v.projectName, nil)
		if err != nil {
			return err
		}

		parts[2] = v.projectName
		v.moduleName = strings.Join(parts, "/")

		_, _ = fmt.Fprintf(os.Stdout, "ok, new module name: \"%s\"", v.moduleName)
	}

	return nil
}

func (v *Options) changeProjectPath() (err error) {
	leaveProjectPath := false
	err = survey.AskOne(&survey.Confirm{
		Message: fmt.Sprintf(`tell me, do you want create project into "%s"`, v.projectDirPath),
	}, &leaveProjectPath, nil)
	if err != nil {
		return err
	}

	if !leaveProjectPath {
		err = survey.AskOne(&survey.Input{
			Message: "ok, where I should store project?",
		}, &v.projectDirPath, nil)
		if err != nil {
			return err
		}

		parts := strings.Split(v.projectDirPath, "/")
		v.projectRootPath = strings.Join(parts[:len(parts)-1], "/")

		_, _ = fmt.Fprintf(os.Stdout, "ok, project path is: \"%s\"\n", v.projectDirPath)
	}

	return nil
}

func (v *Options) initializeGitRepository() (err error) {
	_, _ = fmt.Fprintln(os.Stdout, "initialize git repository. . .")

	if err = exec.Command(v.Options.GitPath, "init", v.projectDirPath).Run(); err != nil {
		return errors.WithMessage(err, "error while initializing git repository")
	}

	return nil
}

func (v Options) createGitIgnoreFile() (err error) {
	_, _ = fmt.Fprintln(os.Stdout, `creating ".gitignore" file. . .`)

	var gitIgnoreFile *os.File
	if gitIgnoreFile, err = os.Create(filepath.Join(v.projectDirPath, ".gitignore")); err != nil {
		return err
	}
	defer func() {
		if closeErr := gitIgnoreFile.Close(); closeErr != nil {
			err = closeErr
		}
	}()

	if _, err = gitIgnoreFile.Write([]byte(gitIgnoreTemplate)); err != nil {
		return err
	}

	return nil
}

func (v Options) createReadmeFile() (err error) {
	_, _ = fmt.Fprintln(os.Stdout, `creating "README.md" file. . .`)

	var (
		readmeFileContent string

		data = map[string]interface{}{
			"header": v.projectName,
			"description": "This project was generated by goproject-cli",
		}
	)
	if readmeFileContent, err = executeTemplate(readmeTemplate, data); err != nil {
		return err
	}

	var readmeFile *os.File
	if readmeFile, err = os.Create(filepath.Join(v.projectDirPath, "README.md")); err != nil {
		return err
	}
	defer func() {
		if closeErr := readmeFile.Close(); closeErr != nil {
			err = closeErr
		}
	}()

	if _, err = readmeFile.Write([]byte(readmeFileContent)); err != nil {
		return err
	}

	return nil
}
